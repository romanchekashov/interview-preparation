const { assert, measurePerformance } = require('../../../Utils');

/**
 * https://stepik.org/lesson/376267/step/4?unit=364077
 *
 * Байдарочный поход
 * N человек хотят пойти в байдарочный поход. На лодочной базе есть неограниченное число одинаковых байдарок,
 * каждая может вместить одного или двух человек
 * с суммарной массой не более D килограмм.
 * За аренду каждой байдарки нужно платить. Люди выстроились от 1 до N по своей массе и просят определить минимальное число байдарок, которое им придется арендовать. Известно, что любой имеет массу не более D килограммов.
 *
 * Входные данные:
 * В первой строке положительные числа N ≤ 10^5 и D ≤ 10^9 через пробел. Во второй строке N чисел A(i) ≤ D через пробел в порядке неубывания, где A(i) – масса очередного человека.
 *
 * Выходные данные:
 * Вывести одно число – минимальное количество байдарок, на которых все желающие смогут отправиться в поход.
 */

/**
 * Сначала ставим 2 указателя на человека ii - в начале (слева) очереди (самого лёгкого), а jj - в конце (справа). Далее пытаемся найти пары, используя так называемый "жадный" алгоритм:
 *
 * if A[i] + A[j] > D:
 * Здесь, если лёгкий (слева, i) и тяжёлый (справа, j) не влезают, то нужна отдельная лодка для этого текущего тяжёлого, значит нужно только декрементировать j.
 *
 * else: # тоже самое, что A[i] + A[j] <= D
 * Тут если текущие лёгкий (слева, i) и текущий тяжелый (справа, j), то для них можно использовать одну лодку, поэтому изменяем оба указателя i и j.
 *
 * if i == j:
 * Если получилось так, что указатели указывают на одного и того же человека, то значит для него пары не нашлось, и поэтому для него нужна отдельная лодка.
 *
 * @param args
 * @return {number}
 */
const solution = (args) => {
    const arr = args.split('\n');
    const line1 = arr[0].split(' ');
    const line2 = arr[1].split(' ');
    const N = parseInt(line1[0]), D = parseInt(line1[1]);
    const nums = line2.map(v => parseInt(v));
    let i = 0, j = N - 1, res = 0;

    while (i <= j) {
        if (nums[i] + nums[j] <= D) {
            i += 1
        }

        res += 1
        j -= 1
    }

    return res;
};

// run(solution);

measurePerformance(() => {
    assert(4, solution('6 6\n1 1 5 5 5 6'));
    assert(3, solution('4 6\n1 2 4 6'));
});
