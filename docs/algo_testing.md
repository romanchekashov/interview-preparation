Как писать тесты для алгоритмов?
---

1. Сложность алгоритмов
    - Чтение/запись/инициализация ячейки памяти стоит одну операцию
    - Можно выполнять арифметические и логические операции с одной ячейкой памяти, а также переходы
    - Похоже на компьютер
    - Сложность алгоритма - порядок количества действий в зависимости от размера входных данных
    - Часто применяют О-нотацию - нестрогая оценка сверху
    - Суть: хотим понимать во сколько раз замедлится наша программа при увеличении размера входных данных
    - У нас есть реализация алгоритма в виде программы. При размере входных данных N время работы программы было измерено и составило T. Данные увеличились в 10 раз:
    - Если сложность: O(1) - нет замедления, O(logN) - замедление примерно в 3 раза, O(N) - замедление в 10 раз, O(NlogN) - примерно в 30 раз, O(N^2) - в 100 раз, O(N^3) - в 1000 раз
      - ```python
        # Time complexity: O(N^3)
        def floyed_algo_to_find_shortest_path_between_two_nodes_in_graph(n):
            # below rows are O(1)
            dist = []
            n = int(input())
            # read matrix below rows are O(N^2)
            for i in range(n):
                dist.append(list(map(int, input().split())))
            # below rows are O(N^3)
            for via in range(n):
                for fr in range(n):
                    for to in range(n):
                        dist[fr][to] = min(dist[fr][to], dist[fr][via] + dist[via][to])
            # below rows are O(N)
            for i in range(n):
                if dist[i][i] < 0:
                    print(i)
        ```
2. Тестирование собственной программы
   - Уровни тестирования:
     - Отсутствие тестирования вообще (программа для себя) 
     - Покрытие тестами, нагрузочное тестирование и т. д. (основная часть промышленной разработки)
     - Формальная верификация программ (микрокод процессора, финансы, космос, медицина и т. д.)
   - Что нужно протестировать:
     - Тесты из условия (если есть)
     - Общие случаи
     - Особые случаи
   - Тесты для максимума последовательности:
     - 1 (3) 2
     - 1 2 (3)
     - (3) 2 1
     - 1 1 1
     - 1
     - 
     - -2 (-1) -3
   - Советы по составлению тестов:
     - Если есть примеры - реши их руками и сверь ответ. Если не совпадает, то либо правильных ответов может быть несколько, либо ты неправильно понял задачу.
     - Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить.
     - Проверь последовательность из одного элемента и пустую последовательность.
     - "Краевые эффекты" - проверь, что программа работает корректно в начале и конце последовательности, сделай тесты, чтобы ответ находился на первом и на последнем месте в последовательности.
     - Составь покрытие всех ветвлений, так чтобы был тест, который входит в каждый if и else.
     - Подбери тесты, чтобы не было ни одного входа в цикл.
     - Один тест - одна возможная ошибка.
   - Задача: Даны три целых числа a, b, c, найдите все корни уравнения a * x^2 + b * x + c = 0 и выведите их в порядке возрастания или выведите Many solutions, если решений бесконечно много.
     ```python
        # Time complexity: O(1)
        # Space complexity: O(1)
        def solve(a, b, c):
            if a == 0:
                if b != 0:
                    print(-c / b)
                if b == 0 and c == 0:
                    print("Many solutions")
            else:    
                d = b * b - 4 * a * c
                if d == 0:
                    x1 = -b / (2 * a)
                    print(x1)
                elif d > 0:
                    x1 = (-b + sqrt(d)) / (2 * a)
                    x2 = (-b - sqrt(d)) / (2 * a)
                    if x1 < x2:
                        print(x1, x2)
                    else:
                        print(x2, x1)
     ```
   - Как допускать меньше ошибок:
     - Написали 3-5 строк - запускаем программу и проверяем с помощью отладчика или отладочного вывода все ли правильно
     - Если что-то неправильно - ошибка, скорее всего, в последних 3-5 строках
     - Если написали много кода, то ошибку сложнее локализовать и вспомнить, что там вообще написано
   - Приемы для тестирования:
     - Если использовать чтение из файла для ввода - не надо заново вводить тесты
     - Тесты внутри файла можно просто переставлять
     - После исправления ошибки нужно прогнать все тесты - возможно появились новые ошибки
     - Решение можно оформить в виде функции и вызывать ее с примерами из условия и вашими тестами
3. Автоматизация тестирования
   - Задача: Нужно купить не менее N гигабайт трафика в роуминге. Есть пакеты трафика на A гигабайт за B рублей и на C гигабайт за D рублей. Необходимо вывести минимальную сумму для покупки.
   - Тесты из условия:
     ```python
     n, a, b, c, d = 35, 10, 9, 20, 17
     ans = 31
     print(n, a, b, c, d, solution(n, a, b, c, d) == ans)
     
     n, a, b, c, d = 55, 30, 20, 20, 16
     ans = 40
     print(n, a, b, c, d, solution(n, a, b, c, d) == ans)
     ```
   - Сертификат(не только показать ответ, но и предъявить решение):
     - Дополнительно к правильному ответу (стоимости в рублях) можно возвращать количество пакетов первого и второго типов
     - Тогда можно добавить проверку на то, что стоимость посчитана верно и что куплено не менее N гигабайт
     ```python
     from random import randint
     
     def genr():
         return randint(1, 10)
     
     for testno in range(100):
         n, a, b, c, d = [genr() for _ in range(5)]
         cost, cnta, cntc = solution(n, a, b, c, d)
         if cnta * b + cntc * d != cost:
             print(n, a, b, c, d, "Wrong cost")
         if cnta * a + cntc * c < n:
             print(n, a, b, c, d, "Wrong count")
     ```
     - Полезные функции Random:
     ```python
     from random import randint, sample, choice, shuffle 
     
     randint(a, b) # случайное число из отрезка [a, b]
     sample(a, b, count) # список случайных чисел из [a, b] длиной count
     choice([1, 2, 3]) # случайное число из списка
     shuffle([1, 2, 3]) # перемешивает список
     ```
   - Стресс-тестирование:
     - Ситуация: есть правильное, но медленное решение (TLE), а есть быстрое, но неправильное (WA)
     - Идея: генерируем маленькие случайные тесты (или перебираем все возможные входные данные целиком), запускаем оба решения и сравниваем ответы
4. Как подготовить тесты для задачи
    - Как делают задачи - 1
      - Условие и решение обсуждается несколькими людьми
      - У составителей нет правильного решения и правильных ответов
      - Если есть сертификат, то пишется чекер, проверяющий его (а если сертификата нет, то он добавляется)
    - Как делают задачи - 2
      - Составляются маленькие тесты, решаются на бумажке
      - Составляются большие тесты с очевидным ответом
      - Другие люди пишут дополнительные решения
      - Пишутся неправильные решения
      - Генерируются специальные или случайные тесты, заваливающие неправильные решения

Тесты для простых задач (памятка)
- Общие случаи - примеры и простые тесты
- Вырожденные случаи (пустая последовательность, один элемент в последовательности и т. п.)
- Минимальное и максимальное число во входных данных
- Последовательности максимальной длины
- Покрытие всех веток if и else
- Перепутанные строгие и нестрогие неравенства

Телеграмм бот, который показывает на каком тесте завалил:
- @gettestfromcontestbot
